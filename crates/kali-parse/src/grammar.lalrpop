use std::str::FromStr;

use kali_ast::{
    BinaryExpr,
    BinaryOp,
    Conditional,
    ConstantType,
    Decl,
    Export,
    Expr,
    FuncDecl,
    FuncDeclParam,
    Import,
    Lambda,
    Literal,
    Match,
    Node,
    Pattern,
    PatternLiteral,
    Stmt,
    TypeExpr,
    UnaryExpr,
    UnaryOp,
};

grammar;

Node<T>: Node<T> = {
    <start:@L> <t:T> <end:@R> => Node::new(t, start..end),
};

Comma0<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Newline0<T>: Vec<T> = {
    <mut v:(<T> "\n"+)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Comma1<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
}

Comma2<T>: Vec<T> = {
    <mut v:(<T> ",")+> <e:T> => {
        v.push(e);
        v
    }
}

DoubleSemi0<T>: Vec<T> = {
    <mut v:(<T> ";;")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Repeated<T>: Vec<T> = {
    <mut v:(<T>)*> => v
}

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
};

Int: i64 = {
    r"-?[0-9]+" => i64::from_str(<>).unwrap(),
};

Float: f64 = {
    r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap(),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

String: String = {
    r#""[^"]*""# => <>.to_string(),
};

Array: Vec<Node<Expr>> = {
    "[" <Comma0<Node<Expr>>> "]" => <>,
};

// tuples must have at least two elements to differentiate from a parenthesized expression
Tuple: Vec<Node<Expr>> = {
    "(" <Comma2<Node<Expr>>> ")" => <>,
};

Literal: Literal = {
    <x:Int> => Literal::Int(x),
    <x:Float> => Literal::Float(x),
    <x:Bool> => Literal::Bool(x),
    <x:String> => Literal::String(x),
    <x:Array> => Literal::Array(x),
    <x:Tuple> => Literal::Tuple(x),
};

Conditional: Conditional = {
    "if" <Node<Expr>> "{" <Node<Expr>> "}" "else" "{" <Node<Expr>> "}" => Conditional::new(<>),
    "if" <cond:Node<Expr>> "{" <body:Node<Expr>> "}" "else" <l:@L> <tail:Conditional> <r:@R> => Conditional::new(cond, body, Node::new(Expr::Conditional(tail), l..r)),
};

Pattern: Pattern = {
    #[precedence(level = "0")]
    "_" => Pattern::Wildcard,
    <Identifier> => Pattern::Identifier(<>),
    // literals
    <Int> => Pattern::Literal(PatternLiteral::Int(<>)),
    <Int> ".." <Int> => Pattern::Literal(PatternLiteral::Range(<>)),
    // compound
    "(" <Comma2<Pattern>> ")" => Pattern::Tuple(<>),
    #[precedence(level = "1")] #[assoc(side = "left")]
    <a:Pattern> "::" <b:Pattern> => Pattern::Cons(Box::new(a), Box::new(b))
}

Lambda: Lambda = {
    // n args, body
    "fn" <Comma1<Identifier>> "->" <Node<Expr>> => Lambda::new(<>),
};

MatchBranch: (Vec<Pattern>, Node<Expr>) = {
    "|" <mut v:(<Pattern> "|")*> <p:Pattern> "->" <e:Node<Atom>> => {
        v.push(p);
        (v, e)
    }
}

Match: Match = {
    "match" <expr:Node<Atom>> "with" <branches:MatchBranch+> => {
        Match::new(expr, branches)
    }
}

pub Atom: Expr = {
    #[precedence(level = "0")]
    "(" <Expr> ")",
    Literal => Expr::Literal(<>),
    Identifier => Expr::Identifier(<>),
    // unary
    "!" <Node<Atom>> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::LogicalNot, <>)),
    "~" <Node<Atom>> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::BitwiseNot, <>)),
    "-" <Node<Atom>> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::Negate, <>)),
    // exp
    #[precedence(level = "1")] #[assoc(side="left")]
    <lhs:Node<Atom>> "**" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Exponentiate, rhs)),
    // mul, div, mod
    #[precedence(level = "2")] #[assoc(side="left")]
    <lhs:Node<Atom>> "*" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Multiply, rhs)),
    <lhs:Node<Atom>> "/" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Divide, rhs)),
    <lhs:Node<Atom>> "%" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Modulo, rhs)),
    // add, sub
    #[precedence(level = "3")] #[assoc(side="left")]
    <lhs:Node<Atom>> "+" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Add, rhs)),
    <lhs:Node<Atom>> "-" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Subtract, rhs)),
    // logical ops
    #[precedence(level = "4")] #[assoc(side="left")]
    <lhs:Node<Atom>> "&&" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LogicalAnd, rhs)),
    <lhs:Node<Atom>> "||" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LogicalOr, rhs)),
    // bitwise ops - these need to be text-based to avoid ambiguities with | in match patterns - annoying!
    #[precedence(level = "5")] #[assoc(side="left")]
    <lhs:Node<Atom>> "land" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseAnd, rhs)),
    <lhs:Node<Atom>> "lxor" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseXor, rhs)),
    <lhs:Node<Atom>> "lor" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseOr, rhs)),
    // shift ops
    #[precedence(level = "6")] #[assoc(side="left")]
    <lhs:Node<Atom>> "<<" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseShiftLeft, rhs)),
    <lhs:Node<Atom>> ">>" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseShiftRight, rhs)),
    // comp ops
    #[precedence(level = "7")] #[assoc(side="left")]
    <lhs:Node<Atom>> "<" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LessThan, rhs)),
    <lhs:Node<Atom>> "<=" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LessThanOrEqual, rhs)),
    <lhs:Node<Atom>> ">" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::GreaterThan, rhs)),
    <lhs:Node<Atom>> ">=" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::GreaterThanOrEqual, rhs)),
    // eq ops
    #[precedence(level = "8")] #[assoc(side="left")]
    <lhs:Node<Atom>> "==" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Equal, rhs)),
    <lhs:Node<Atom>> "!=" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::NotEqual, rhs)),
    // cons
    #[precedence(level = "9")] #[assoc(side="right")]
    <lhs:Node<Atom>> "::" <rhs:Node<Atom>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Concatenate, rhs)),
};

pub Expr: Expr = {
    #[precedence(level = "0")]
    Atom => <>,
    #[precedence(level = "1")]
    Conditional => Expr::Conditional(<>),
    Match => Expr::Match(<>),
    Lambda => Expr::Lambda(<>),
};

pub ConstantType: ConstantType = {
    "int" => ConstantType::Int,
    "float" => ConstantType::Float,
    "bool" => ConstantType::Bool,
    "string" => ConstantType::String,
}

pub TypeExpr: TypeExpr = {
    ConstantType => TypeExpr::Constant(<>),
}
 
pub Import: Import = {
    "import" "{" <symbols:Comma0<Identifier>> "}" "from" <path:String> => Import::Named { symbols, path },
    "import" "*" "from" <path:String> => Import::Wildcard { path },
    "import" "*" "as" <alias:Identifier> "from" <path:String> => Import::NamedWildcard { alias, path }
};

pub Export: Export = {
    "export" "{" <symbols:Comma0<Identifier>> "}" => Export::new(symbols),
};

pub Decl: Decl = {
    "let" <name:Identifier> "=" <value:Node<Expr>> => Decl::new(name, value),
}

pub FuncDecl: FuncDecl = {
    "fn" <name:Identifier> <params:FuncDeclParam*> "=" <body:Node<Expr>> => FuncDecl::new(name, params, None, body),
}

FuncDeclParam: FuncDeclParam = {
    <name:Identifier> ":" <ty:TypeExpr> => FuncDeclParam::new(name, Some(ty)),
    <name:Identifier> => FuncDeclParam::new(name, None),
}

pub Stmt: Stmt = {
    Import => Stmt::Import(<>),
    Export => Stmt::Export(<>),
    Decl => Stmt::Decl(<>),
    FuncDecl => Stmt::FuncDecl(<>),
}

pub Stmts: Vec<Node<Stmt>> = {
    <DoubleSemi0<Node<Stmt>>>
}
