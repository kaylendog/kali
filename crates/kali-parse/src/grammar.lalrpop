use std::str::FromStr;

use kali_ast::{Expr, BinaryExpr, BinaryOp, Literal, UnaryExpr, UnaryOp, Conditional};

grammar;

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
};

Int: i64 = {
    r"-?[0-9]+" => i64::from_str(<>).unwrap(),
};

Float: f64 = {
    r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap(),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

String: String = {
    r#""[^"]*""# => <>.to_string(),
};

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Array: Vec<Expr> = {
    "[" <Comma<Expr>> "]" => <>,
};

Tuple: Vec<Expr> = {
    "(" <Comma<Expr>> ")" => <>,
};

Literal: Literal = {
    <x:Int> => Literal::Int(x),
    <x:Float> => Literal::Float(x),
    <x:Bool> => Literal::Bool(x),
    <x:String> => Literal::String(x),
    <x:Array> => Literal::Array(x),
};

Term: Expr = {
    Literal => Expr::Literal(<>),
    Identifier => Expr::Identifier(<>),
    "(" <Expr> ")"
};

UnaryNegate: Expr = {
    "-" <UnaryNegate> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::Negate, <>)),
    Term,
};

UnaryLogicalNot: Expr = {
    "!" <UnaryLogicalNot> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::LogicalNot, <>)),
    UnaryNegate,
};

UnaryBitwiseNot: Expr = {
    "~" <UnaryBitwiseNot> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::BitwiseNot, <>)),
    UnaryLogicalNot,
};

ExponentOp: BinaryOp = {
    "**" => BinaryOp::Exponentiate,
};

Exponent: Expr = {
    Exponent ExponentOp UnaryBitwiseNot => Expr::BinaryExpr(BinaryExpr::new(<>)),
    UnaryBitwiseNot,
};

FactorOp: BinaryOp = {
    "*" => BinaryOp::Multiply,
    "/" => BinaryOp::Divide,
    "%" => BinaryOp::Modulo,
};

Factor: Expr = {
    Factor FactorOp Exponent => Expr::BinaryExpr(BinaryExpr::new(<>)),
    Exponent,
};

SumOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Subtract,
};

Sum: Expr = {
    Sum SumOp Factor => Expr::BinaryExpr(BinaryExpr::new(<>)),
    Factor,
};

Cons: Expr = {
    <lhs:Cons> "::" <rhs:Sum> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Concatenate, rhs)),
    Sum,
};

ShiftOp: BinaryOp = {
    "<<" => BinaryOp::BitwiseShiftLeft,
    ">>" => BinaryOp::BitwiseShiftRight,
};

Shift: Expr = {
    Shift ShiftOp Cons => Expr::BinaryExpr(BinaryExpr::new(<>)),
    Cons,
};

ComparatorOp: BinaryOp = {
    "<" => BinaryOp::LessThan,
    "<=" => BinaryOp::LessThanOrEqual,
    ">" => BinaryOp::GreaterThan,
    ">=" => BinaryOp::GreaterThanOrEqual,
};

Comparator: Expr = {
    Comparator ComparatorOp Shift => Expr::BinaryExpr(BinaryExpr::new(<>)),
    Shift,
};

EqualityOp: BinaryOp = {
    "==" => BinaryOp::Equal,
    "!=" => BinaryOp::NotEqual,
};

Equality: Expr = {
    Equality EqualityOp Comparator => Expr::BinaryExpr(BinaryExpr::new(<>)),
    Comparator,
};

BitwiseAnd: Expr = {
    <lhs:BitwiseAnd> "&" <rhs:Equality> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseAnd, rhs)),
    Equality,
};

BitwiseXor: Expr = {
    <lhs:BitwiseXor> "^" <rhs:BitwiseAnd> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseXor, rhs)),
    BitwiseAnd,
};

BitwiseOr: Expr = {
    <lhs:BitwiseOr> "|" <rhs:BitwiseXor> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseOr, rhs)),
    BitwiseXor,
};

LogicalAnd: Expr = {
    <lhs:LogicalAnd> "&&" <rhs:BitwiseOr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LogicalAnd, rhs)),
    BitwiseOr,
};

LogicalOr: Expr = {
    <lhs:LogicalOr> "||" <rhs:LogicalAnd> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LogicalOr, rhs)),
    LogicalAnd,
};

Conditional: Expr = {
    "if" <Expr> "{" <Expr> "}" "else" "{" <Expr> "}" => Expr::Conditional(Conditional::new(<>)),
    "if" <Expr> "{" <Expr> "}" "else" <Conditional> => Expr::Conditional(Conditional::new(<>)),
};

pub Expr: Expr = {
    LogicalOr,
    Conditional
};
