use std::str::FromStr;

use kali_ast::{Expr, BinaryExpr, BinaryOp, Literal, UnaryExpr, UnaryOp, Conditional};

grammar;

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
};

Int: i64 = {
    r"-?[0-9]+" => i64::from_str(<>).unwrap(),
};

Float: f64 = {
    r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap(),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

String: String = {
    r#""[^"]*""# => <>.to_string(),
};

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Array: Vec<Expr> = {
    "[" <Comma<Expr>> "]" => <>,
};

Tuple: Vec<Expr> = {
    "(" <Comma<Expr>> ")" => <>,
};

Literal: Literal = {
    <x:Int> => Literal::Int(x),
    <x:Float> => Literal::Float(x),
    <x:Bool> => Literal::Bool(x),
    <x:String> => Literal::String(x),
    <x:Array> => Literal::Array(x),
};

Conditional: Conditional = {
    "if" <Expr> "{" <Expr> "}" "else" "{" <Expr> "}" => Conditional::new(<>),
    "if" <cond:Expr> "{" <body:Expr> "}" "else" <tail:Conditional> => Conditional::new(cond, body, Expr::Conditional(tail)),
};


pub Expr: Expr = {
    #[precedence(level ="0")]
    "(" <Expr> ")",
    Literal => Expr::Literal(<>),
    Identifier => Expr::Identifier(<>),
    Conditional => Expr::Conditional(<>),
    // unary
    "!" <Expr> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::LogicalNot, <>)),
    "~" <Expr> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::BitwiseNot, <>)),
    "-" <Expr> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::Negate, <>)),
    // exp
    #[precedence(level ="1")] #[assoc(side="left")]
    <lhs:Expr> "**" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Exponentiate, rhs)),
    // mul, div, mod
    #[precedence(level ="2")] #[assoc(side="left")]
    <lhs:Expr> "*" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Multiply, rhs)),
    <lhs:Expr> "/" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Divide, rhs)),
    <lhs:Expr> "%" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Modulo, rhs)),
    // add, sub
    #[precedence(level ="3")] #[assoc(side="left")]
    <lhs:Expr> "+" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Add, rhs)),
    <lhs:Expr> "-" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Subtract, rhs)),
    // logical ops
    #[precedence(level ="4")] #[assoc(side="left")]
    <lhs:Expr> "&&" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LogicalAnd, rhs)),
    <lhs:Expr> "||" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LogicalOr, rhs)),
    // bitwise ops
    #[precedence(level ="5")] #[assoc(side="left")]
    <lhs:Expr> "&" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseAnd, rhs)),
    <lhs:Expr> "^" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseXor, rhs)),
    <lhs:Expr> "|" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseOr, rhs)),
    // shift ops
    #[precedence(level ="6")] #[assoc(side="left")]
    <lhs:Expr> "<<" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseShiftLeft, rhs)),
    <lhs:Expr> ">>" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseShiftRight, rhs)),
    // comp ops
    #[precedence(level ="7")] #[assoc(side="left")]
    <lhs:Expr> "<" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LessThan, rhs)),
    <lhs:Expr> "<=" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LessThanOrEqual, rhs)),
    <lhs:Expr> ">" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::GreaterThan, rhs)),
    <lhs:Expr> ">=" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::GreaterThanOrEqual, rhs)),
    // eq ops
    #[precedence(level ="8")] #[assoc(side="left")]
    <lhs:Expr> "==" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Equal, rhs)),
    <lhs:Expr> "!=" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::NotEqual, rhs)),
    // cons
    #[precedence(level ="9")] #[assoc(side="right")]
    <lhs:Expr> "::" <rhs:Expr> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Concatenate, rhs)),
};
