use std::str::FromStr;

use kali_ast::{
    BinaryExpr,
    BinaryOp,
    Conditional,
    Decl,
    Export,
    Expr,
    Import,
    Lambda,
    Literal,
    Node,
    Stmt,
    UnaryExpr,
    UnaryOp
};

grammar;

Node<T>: Node<T> = {
    <start:@L> <t:T> <end:@R> => Node::new(t, start..end),
};

Comma0<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Comma1<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
}

Comma2<T>: Vec<T> = {
    <mut v:(<T> ",")+> <e:T> => {
        v.push(e);
        v
    }
}

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
};

Int: i64 = {
    r"-?[0-9]+" => i64::from_str(<>).unwrap(),
};

Float: f64 = {
    r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap(),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

String: String = {
    r#""[^"]*""# => <>.to_string(),
};

Array: Vec<Node<Expr>> = {
    "[" <Comma0<Node<Expr>>> "]" => <>,
};

// tuples must have at least two elements to differentiate from a parenthesized expression
Tuple: Vec<Node<Expr>> = {
    "(" <Comma2<Node<Expr>>> ")" => <>,
};

Literal: Literal = {
    <x:Int> => Literal::Int(x),
    <x:Float> => Literal::Float(x),
    <x:Bool> => Literal::Bool(x),
    <x:String> => Literal::String(x),
    <x:Array> => Literal::Array(x),
    <x:Tuple> => Literal::Tuple(x),
};

Conditional: Conditional = {
    "if" <Node<Expr>> "{" <Node<Expr>> "}" "else" "{" <Node<Expr>> "}" => Conditional::new(<>),
    "if" <cond:Node<Expr>> "{" <body:Node<Expr>> "}" "else" <l:@L> <tail:Conditional> <r:@R> => Conditional::new(cond, body, Node::new(Expr::Conditional(tail), l..r)),
};

Lambda: Lambda = {
    // n args, body
    "fn" <Comma1<Identifier>> "->" <Node<Expr>> => Lambda::new(<>),
};

pub Expr: Expr = {
    #[precedence(level = "0")]
    "(" <Expr> ")",
    Literal => Expr::Literal(<>),
    Identifier => Expr::Identifier(<>),
    Conditional => Expr::Conditional(<>),
    // unary
    "!" <Node<Expr>> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::LogicalNot, <>)),
    "~" <Node<Expr>> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::BitwiseNot, <>)),
    "-" <Node<Expr>> => Expr::UnaryExpr(UnaryExpr::new(UnaryOp::Negate, <>)),
    // exp
    #[precedence(level = "1")] #[assoc(side="left")]
    <lhs:Node<Expr>> "**" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Exponentiate, rhs)),
    // mul, div, mod
    #[precedence(level = "2")] #[assoc(side="left")]
    <lhs:Node<Expr>> "*" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Multiply, rhs)),
    <lhs:Node<Expr>> "/" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Divide, rhs)),
    <lhs:Node<Expr>> "%" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Modulo, rhs)),
    // add, sub
    #[precedence(level = "3")] #[assoc(side="left")]
    <lhs:Node<Expr>> "+" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Add, rhs)),
    <lhs:Node<Expr>> "-" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Subtract, rhs)),
    // logical ops
    #[precedence(level = "4")] #[assoc(side="left")]
    <lhs:Node<Expr>> "&&" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LogicalAnd, rhs)),
    <lhs:Node<Expr>> "||" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LogicalOr, rhs)),
    // bitwise ops
    #[precedence(level = "5")] #[assoc(side="left")]
    <lhs:Node<Expr>> "&" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseAnd, rhs)),
    <lhs:Node<Expr>> "^" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseXor, rhs)),
    <lhs:Node<Expr>> "|" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseOr, rhs)),
    // shift ops
    #[precedence(level = "6")] #[assoc(side="left")]
    <lhs:Node<Expr>> "<<" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseShiftLeft, rhs)),
    <lhs:Node<Expr>> ">>" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::BitwiseShiftRight, rhs)),
    // comp ops
    #[precedence(level = "7")] #[assoc(side="left")]
    <lhs:Node<Expr>> "<" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LessThan, rhs)),
    <lhs:Node<Expr>> "<=" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::LessThanOrEqual, rhs)),
    <lhs:Node<Expr>> ">" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::GreaterThan, rhs)),
    <lhs:Node<Expr>> ">=" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::GreaterThanOrEqual, rhs)),
    // eq ops
    #[precedence(level = "8")] #[assoc(side="left")]
    <lhs:Node<Expr>> "==" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Equal, rhs)),
    <lhs:Node<Expr>> "!=" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::NotEqual, rhs)),
    // cons
    #[precedence(level = "9")] #[assoc(side="right")]
    <lhs:Node<Expr>> "::" <rhs:Node<Expr>> => Expr::BinaryExpr(BinaryExpr::new(lhs, BinaryOp::Concatenate, rhs)),
    // lambda
    #[precedence(level ="10")] #[assoc(side="right")]
    Lambda => Expr::Lambda(<>),
};
 
pub Import: Import = {
    "import" "{" <symbols:Comma0<Identifier>> "}" "from" <path:String> => Import::new(path, symbols),
};

pub Export: Export = {
    "export" "{" <symbols:Comma0<Identifier>> "}" => Export::new(symbols),
};

pub Decl: Decl = {
    "let" <name:Identifier> "=" <value:Node<Expr>> => Decl::new(name, value),
}

pub Stmt: Stmt = {
    Import => Stmt::Import(<>),
    Export => Stmt::Export(<>),
}
