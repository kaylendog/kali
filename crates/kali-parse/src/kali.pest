///! The parser for the Kali language.

/// The empty string.
EPSILON = { "" }

/// Whitespace rule.
WHITESPACE = _{ " " | "\n" | "\t" | "\r" }

/// A sign, either positive or negative.
sign = { "+" | "-" }

/// A prefixed binary integer literal.
prefixed_binary_integer_literal = @{ "0b" ~ ASCII_BIN_DIGIT ~ (ASCII_BIN_DIGIT | "_" )* }

/// A signed binary integer literal. Identical to a binary integer literal, but with an optional "+" or "-" prefix.
signed_prefixed_binary_integer_literal = @{ sign ~ prefixed_binary_integer_literal }

/// A prefixed octal integer literal.
prefixed_octal_integer_literal = @{ "0o" ~ ASCII_OCT_DIGIT ~ (ASCII_OCT_DIGIT | "_" )* }

/// A signed octal integer literal. Identical to an octal integer literal, but with an optional "+" or "-" prefix.
signed_prefixed_octal_integer_literal = @{ sign ~ prefixed_octal_integer_literal }

/// An unprefixed decimal integer literal.
decimal_integer_literal = @{ ASCII_DIGIT ~ (ASCII_DIGIT | "_" )* }

/// A prefixed decimal integer literal.
prefixed_decimal_integer_literal = @{ "0d" ~ decimal_integer_literal }

/// A signed decimal integer literal. Identical to a decimal integer literal, but with an optional "+" or "-" prefix.
signed_decimal_integer_literal = { sign ~ decimal_integer_literal }

/// A signed, prefixed decimal integer literal. Identical to a prefixed decimal integer literal, but with an optional "+" or "-" prefix.
signed_prefixed_decimal_integer_literal = { sign ~ prefixed_decimal_integer_literal }

/// A prefixed hexadecimal integer literal.
prefixed_hexadecimal_integer_literal = { "0x" ~ ASCII_HEX_DIGIT ~ (ASCII_HEX_DIGIT | "_" )* }

/// A signed hexadecimal integer literal. Identical to a hexadecimal integer literal, but with an optional "+" or "-" prefix.
signed_hexadecimal_integer_literal = { sign ~ prefixed_hexadecimal_integer_literal }

/// An integer literal, in one of the supported bases.
///
/// Kali supports the following integer literal formats:
/// - Binary: `0b` followed by a sequence of binary digits.
/// - Octal: `0o` followed by a sequence of octal digits.
/// - Decimal: An optional `0d` followed by a sequence of decimal digits.
/// - Hexadecimal: `0x` followed by a sequence of hexadecimal digits.
integer_literal = { 
    prefixed_binary_integer_literal
    | signed_prefixed_binary_integer_literal 
    | prefixed_octal_integer_literal
    | signed_prefixed_octal_integer_literal 
    | decimal_integer_literal
    | prefixed_decimal_integer_literal
    | signed_decimal_integer_literal
    | signed_prefixed_decimal_integer_literal
    | prefixed_hexadecimal_integer_literal
    | signed_hexadecimal_integer_literal
}

/// The exponent token for a float literal.
float_exponent = { "e" | "E" }

/// The exponent part of a float literal.
float_literal_exponent = { float_exponent ~ sign? ~ decimal_integer_literal }

/// A float literal without a decimal fraction or exponent.
float_literal_prefix = { decimal_integer_literal ~ "." }

/// A float literal with a decimal fraction.
float_literal_suffix = { "." ~ decimal_integer_literal }

/// A float literal with no decimal fraction and required exponent part.
float_literal_with_exponent = { decimal_integer_literal ~ float_literal_exponent }

/// A float literal with a decimal fraction.
float_literal_prefix_suffix = { decimal_integer_literal ~ "." ~ decimal_integer_literal }

/// A float literal with a decimal fraction and exponent.
float_literal_suffix_with_exponent = { float_literal_suffix ~ float_literal_exponent }

/// A float literal with a decimal fraction and exponent.
float_literal_prefix_suffix_with_exponent = { decimal_integer_literal ~ "." ~ decimal_integer_literal ~ float_literal_exponent }

/// A float literal.
float_literal = {
    float_literal_prefix
    | float_literal_suffix
    | float_literal_with_exponent
    | float_literal_prefix_suffix
    | float_literal_suffix_with_exponent
    | float_literal_prefix_suffix_with_exponent
}

/// A boolean literal.
boolean_literal = { "true" | "false" }

/// An array literal.
array_literal = { "[" ~ expr ~ ( "," ~ expr )* ~ "]" }

/// Unit literal.
unit_literal = { "()" }

/// A tuple literal.
tuple_literal = { "(" ~ expr ~ ( "," ~ expr )* ~ ")" }

/// A sum type variant literal.
sum_type_literal = { identifier ~ tuple_literal? }

/// A field in a struct literal.
struct_literal_field = { identifier ~ ":" ~ expr }

/// A struct literal.
struct_literal = { "{" ~ struct_literal_field ~ ("," ~ struct_literal_field)* ~ "}" }

/// A literal value.
literal = { 
    integer_literal 
    | float_literal 
    | boolean_literal
    | array_literal 
    | unit_literal 
    | tuple_literal 
    | sum_type_literal
}

/// An identifier.
identifier = { ( ASCII_ALPHA | LETTER | "_" ) ~ ( ASCII_ALPHANUMERIC | LETTER | "_" )* }

/// An expression.
expr = { literal }

/// A primitive type.
primitive_type = { "bool" | "int" | "float" | "string" }

/// A tuple type.
tuple_type = { "(" ~ type ~ ( "," ~ type )* ~ ")" }

/// A sum type variant.
sum_type_variant = { identifier ~ tuple_type }

/// A sum type.
sum_type = { sum_type_variant ~ ( "|" ~ sum_type_variant )* }

/// A struct type field.
struct_type_field = { identifier ~ ":" ~ type }

/// A struct type.
struct_type = { "{" ~ struct_type_field ~ ( ";" ~ struct_type_field )* ~ "}" }

/// An array type atom, used to prevent left-recursion.
array_type_atom = { primitive_type | tuple_type | sum_type | struct_type }

/// An array type.
array_type = { array_type_atom ~ "[]" }

/// A type.
type = {
    primitive_type | tuple_type | sum_type | struct_type | array_type
}

/// A type declaration.
type_declaration = { "type" ~ identifier ~ "=" ~ type }

/// A statement in the language.
statement = { type_declaration | expr }

program = { SOI ~ statement* ~ EOI }
